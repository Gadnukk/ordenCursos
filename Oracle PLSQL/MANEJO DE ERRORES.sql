--MANEJO DE ERRORES
	--NO_DATA_FOUND
	--OTHERS

--Exception para SELECT 
   EXCEPTION WHEN NO_DATA_FOUND THEN
             psMSG:='No se encontraron datos';
             WHEN OTHERS THEN
             psMSG:=SQLERRM;


--MENSAJES PRECONFIGURADOS
	  
SQLCODE --Codigo del error
SQLERRM --Texto del mensaje de error
USER --usuario actual de la base de datos



LSERRORLOG VARCHAR2(440) := 
SYS_CONTEXT('USERENV', 'DB_NAME') || '.' ||
 SYS_CONTEXT('USERENV', 'SESSION_USER') ||
 '.' ||
 'SP_MIDTV_CONSULTA_RECLAMOS' || ' - '; --Nombre del SP

--Apertura de Cursores para grilla
OPEN POCUR FOR
OPEN CUR FOR

--Exception para Cursores
-- SI EL CURSOR NO FUE ABIERTO, SE ABRE CON UN REGISTRO FICTICIO.
-- SI NO SE HACE ESTO, SE PUEDE PRODUCIR UN ERROR POR LEER MEMORIA PROTEGIDA.
IF (NOT POCUR%ISOPEN) THEN
 OPEN POCUR FOR 
	SELECT 'DUMMY' AS DUMMY FROM DUAL;
END IF;

IF NOT CUR%ISOPEN
    THEN
       OPEN CUR FOR
        SELECT 'Se produjo un errror inesperado' "Mensaje" FROM DUAL;
END IF;

--Al final del SP. Por cualquier error que sea aparte de la asignacion de una variable por select 
EXCEPTION
WHEN OTHERS THEN
 LNERRORNUM := SQLCODE;
 LSERRORDESC := 'ERROR ' || TO_CHAR(LNERRORNUM) || ' - ' || SQLERRM(LNERRORNUM);
 -- NOTIFICACIÓN DE ERROR.
 LSERRORLOG := LSERRORLOG || LSERRORDESC;
 -- DEVUELVE EL ERROR EN EL PARÁMETRO DE SALIDA.
 PS_RET_MESSAGE := SUBSTR(LSERRORDESC, 1,440);
 -- DESHACE LA TRANSACCIÓN COMPLETA SI LA OPERACIÓN FALLÓ.
 ROLLBACK;
-- DESHACE LA TRANSACCIÓN COMPLETA SI LA OPERACIÓN FALLÓ.
 ROLLBACK;
